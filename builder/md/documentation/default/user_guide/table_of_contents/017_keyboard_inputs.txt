# KEYBOARD INPUTS

AOZ has a full range of keyboard input commands.

You can read keys one at a time, including modifier keys (Ctrl, Shift, Alt, Meta), and locking keys like Caps lock. Some keycodes are stored in the input buffer (an area of memory reserved for keypresses, but not yet processed). You can even detect multiple keypresses at the same time.

There are four types of keyboard input instructions:
**Variable** This input gets data from any simple type like a string, integer, or number, from the keyboard, and feeds it directly into each input variable. Multiple variables can be input using commas (or the **Enter** key) to separate the inputs.
**Character** This type of input gets string-only data from the keyboard. Character refers to any single letter, digit, special symbol, etc.
**Buffer** This type allows you to interact with the keyboard buffer directly.
**State** This type of input checks the current state of a key to see if it is pressed or not, but does not have to fill a variable with the result.

<![endif]-->

## Keyboard variable inputs

### Input

We have four forms of the Input instruction.

**Input VARNAME { , VARNAME$, VARNAME#, ... }**

**_Description:_** This Instruction accepts keyboard input for simple variables. Input from the keyboard is inserted into the variable(s) specified by VARNAME, VARNAME$, etc. The input will be displayed on screen as it is typed, with simple editing allowed using the backspace. Each input should be separated by a comma, or the **Enter** key. When the **Enter** key is pressed _after_ the last variable terminates the input command inserts the data into the specified variable(s).

**_Parameter(s):_** Any number of parameters may be requested, of any simple variable type: (**Integer**, **Number**, or **String**). Each variable must be separated by a comma or the **Enter** key.

Example:
```basic
Do  
	Input A$  
	Print A$  
Loop
```

Or you can type:
```basic
Do  
	Input A,B$,C#  
	Print A,B$,C#  
Loop
```
<BR>

#### **Input TEXT$ ; VARNAME { , VARNAME$, VARNAME#, ... }**

**_Description:_** An alternate form of the previously described Input Instruction, which also displays a text TEXT$ just before the input. Otherwise, the command works identically.

Example:
```basic
Do 
	Input "Enter A,B$,and C#: ";A,B$,C#  
	Print "Inputs: ";A,B$,C#  
	Refresh  
Loop
```
With the exception of showing "Enter A, B$, and C#:"  just before accepting the inputs, this works identically to the simple Input command.
<BR>

#### **Line Input VARNAME { , VARNAME$, VARNAME#, ... }**

**_Description:_**  Functions identically to the Input command, except that it accepts all printable characters including the comma as part of the input. The **Enter** key is used to separate each input. See the description of the **Input** command for more details.

NOTE: If the "Please redo from start" error occurs, input starts again with the first variable.
<BR>

#### **Line Input TEXT$ ; VARNAME {, VARNAME$ VARNAME#, ...}**

**_Description:_** As with the standard **Input** command, **Line Input** also has the option of displaying a prompt string before accepting inputs. Otherwise, this works identically to the **Line Input** command. See the description of **Line Input** for more details.
<BR><BR>


### Keyboard Buffer

These commands allow you to interact with the keyboard buffer directly.

#### **Put Key K$** Put Key is NOT CURRENTLY IMPLEMENTED, but will be soon, so:

**_Description:_** Inserts the specified string (**K$**) into the input buffer directly, as if it was typed from the keyboard. This is often used to pre-fill values for the **Input** instructions._

_Example:_
```basic
Do  
	Put Key "YES"  
	Input "Do you like AOZ? ";A$  
	A$=Upper$(A$)  
Loop
```
<BR>

**Clear Key**

**_Description:_** Clears the contents of the input buffer. This can be called immediately before **Wait Key** or other keyboard commands to ensure that we're waiting for new input.
<BR>

**Key Speed**
 Key Speed TIMELAG,DELAYSPEED

**_Description:_** Sets the speed at which input is accepted. **TIMELAG** is the time before the repeat starts. **DELAYSPEED** indicates the speed at which each keypress is accepted.
<BR>


## Keyboard character input

Character inputs accept only strings from the keyboard, usually one character at a time.

### Inkey$

_Description:_ This Function checks the input buffer to see if a key has been pressed. If yes, it puts that character into the function result, and removes it from the input buffer.

**_Return Value:_** The result (X$ below) is a single character string containing the value of the next character from the input buffer. If the input buffer was empty at the time **Inkey$** was called, then the result is an empty string: "".

_Example#1 of Inkey$:_

```basic
Centre "Press d or f " : Print
Do
	A$ = Inkey$
	If A$ = "d" Then print "d";
	If A$ = "f" Then print "f";
	Refresh
Loop
```
<BR>


_Example#2 of Inkey$:_
```basic
Result$=""
Do
	X$=Inkey$ : If X$ >= "@" And X$ <= "~" Then Print X$; : Result$=Result$+X$
	If X$=Chr$(8) Then Result$=Left$(Result$,Len(Result$)-1)
	If X$=Chr$(13) Then Exit
	Refresh ' give the program time to run
	Cls : Print Result$
Loop
Cls : Print Result$
```

The above code will get printable characters one at a time, and append them to **Result$**. The backspace and enter special characters are also handled.
<BR>

#### Input$(N)

**_Description:_** Returns a string of **N** printable characters long. Once the specified number of characters (**N**) has been reached, the result is returned, and processing continues with the next statement. No editing is possible.

**_Return Value:_** The **_String_** result (**X$**) returned is exactly **N** characters long.

_Example:_

**Do****  
X$=Input$(3)  
Print X$  
Wait Vbl  
Loop**

The above code accepts a 3 character string from the keyboard, and puts it into **X$**.
  

## Reading the keyboard state

### Wait Key
**_Description:_** Waits for any keyboard key to be pressed before acting on the next instruction.

_Example:_

**Print "Please press a key" : Wait key : Print "Thank you!"**
In the example above, "Thank you!" will not be printed until a key is pressed.
<BR>

### Wait Input
**_Description:_** This very useful instruction waits for any key or click on the keyboard, joystick, mouse (not gamepad) to be pressed before acting on the next instruction.

_Exemple :_
**Wait Input : Print "Moving forward"**
<BR>

### Wait Click

**_Description:_** Same but waits for a mouse click to be pressed before acting on the next instruction.
<BR>

### Key State

**_Description:_** Returns true when a specific key is pressed.
**_Parameter:_** The scan code (see next page) of the key to be tested.
**_Return Value:_** The **_boolean_** result is _true_ if the key specified by the scan code (here $42 in Hexadecimal or 66 in decimal) is pressed.

_Example:_
```basic
Result$=""
CODE=42 : REM "it is the scan code of the letter B"****  
Do  
	If Key State(CODE) Then Print "Key: ";CODE;" (";Chr$(CODE);") was pressed."  
	Refresh  
Loop
```
In the example above, the **Print** will not occur until the specified key: "B" is pressed.
<BR>


### Key Name$

**_Description:_** Returns a **_string_** containing a textual name for the key pressed.
**_Return Value:_** The **_string_** result contains a textual description of the key pressed. Consult the appendix **Keyboard Codes** for a list of the key names and scan codes.

_Example:_
```basic
Do
	Locate 1,1 : Print "hit gently your keyboard: ";
	ik$ = Inkey$
	If ik$ <> ""
		Print ik$;"  ";
		k$=Key Name$ : Print k$;
	End If
	Refresh
Loop
```
The above code will display the key names of the QWERTY keyboard as the keys are pressed.
<BR>

### ScanCode

**_Description:_** Returns the scan code of the _last key_ in the input buffer as read by **Inkey$**.
**_Return Value:_** The **_integer_** result contains the scan code of the _last key_ pressed, or 0 if the input buffer is empty.

_Example:_
```basic
Locate 0,0 : Print Manifest$
Do
	I$=Inkey$
	If I$ <> "" ' Do we have a key?
		SC=ScanCode
		Locate 1,1 : Print I$, Hex$(SC,2) : SC=0
	End If
	Refresh
Loop
```
The example above will display the printable key pressed and it's scan code in Hexadecimal.
<BR>

### Key Shift

**_Description:_** Determines which (if any) modifier keys are currently held down. Modifier keys are those that are usually intended to modify the value and/or function of another key being pressed at the same time.
**_Return Value:_** The integer result contains a bitmap indicating which modifier keys are currently pressed. The bitmap is filled as follows:
 
**Bit Value  Key Tested**  
0  $0001  Left Shift  
1  $0002  Right Shift  
2  $0004  Left Ctrl  (Caps Lock on Amiga)  
3  $0008  Right Ctrl (either Ctrl on Amiga)  
4  $0010  Left Alt  
5  $0020  Right Alt  
6  $0040  Left Meta  (Amiga/Cmd/Windows)  
7  $0080  Right Meta (Amiga/Cmd/Windows)  
8  $0100  Caps Lock (AOZ mode only)  
15  $8008  Left Ctrl (Amiga mode only - bit 3 also set for compatibility)

**Amiga manifest NOTE:**  More combinations of modifiers are allowed in AOZ than on an actual Amiga computer. For example, you can read both the _left_ and _right_ shift keys at the same time. Also, a new bit position ($8000) has been added to represent the _Left Ctrl_ key. For backward compatibility reasons, in Amiga mode, EITHER Ctrl key will set bit 3. In the future, a tag may be added to only return _Left Ctrl_ when it is pressed, instead of also activating the _Right Ctrl_ bit.

Example:
```basic
KS$=""
Do
	KS=Key Shift
	If KS <> 0
		If (KS & 1)=1 Then KS$=KS$ + "Left Shift| "
		If (KS & 2)=2 Then KS$=KS$ + "Right Shift| "
		If (KS & 4)=4 Then If Manifest$="amiga" Then KS$=KS$+"Caps Lock| " Else KS$=KS$+"Left Ctrl| "
		If (KS & 8)=8 Then KS$=KS$+"Right Ctrl| "
		If (KS & 16)=16 Then KS$=KS$+"Left Alt| "
		If (KS & 32)=32 Then KS$=KS$+"Right Alt| "
		If (KS & 64)=64 Then KS$=KS$+"Left Meta| "
		If (KS & 128)=128 Then KS$=KS$+"Right Meta| "
		If (KS & 256)=256 Then KS$=KS$+"Caps Lock| "  ' Only for AOZ
		If (KS & $8000)=$8000 Then KS$=KS$+"Left Ctrl| "  ' Only for Amiga
	End If
	Locate 1,0 : Print Manifest$
	Locate 1,1 : Print "KS: ";Right$(Bin$(KS,16),16)
	Locate 1,2 : Print KS$
	Refresh
Loop
```
**Hardware NOTE:** Due to hardware differences in keyboards, certain combinations of modifier keys with or without other keys pressed may or may not be possible, so try to keep your keyboard interface simple, and test it thoroughly, in order to avoid compatibility issues.
<BR>

### ScanShift

**_Description:_** Determines which (if any) modifier keys were held down while the last key in the input buffer (read by **Inkey$**) was pressed. The modifier keys are those that are intended to modify the value and/or function of the _last key_ in the input buffer. This function operates exactly as the **_Key Shift_** function except that it relates to the _last key_ in the input buffer vs. the current modifiers state.

**_Return Value:_** The **_integer_** result contains a bitmap indicating which modifier keys were pressed while the last key in the input buffer was pressed. The bitmap table is above with **Key Shift**.

Example:
```basic
SS$=""
Do  
	I$=Inkey$ ' Get a key from the input buffer.  
	SS=ScanShift ' Get that key's shift states  
	Locate 0,0 : Print Manifest$
	
	If I$<>""  
		Locate 0,1 : Print I$;" "  
		Locate 0,2: Print "SS: ";Right$(Bin$(SS,16),16)  
		If SS <> 0  
			If (SS & 1)=1 Then SS$=SS$ + "Left Shift|"  
			If (SS & 2)=2 Then SS$=SS$ + "Right Shift|"  
			If (SS & 4)=4 Then If Manifest$="amiga" Then SS$=SS$+"Caps Lock|" Else SS$=SS$+"Left Ctrl|"  
			If (SS & 8)=8 Then SS$=SS$+"Right Ctrl|"  
			If (SS & 16)=16 Then SS$=SS$+"Left Alt|"  
			If (SS & 32)=32 Then SS$=SS$+"Right Alt|"  
			If (SS & 64)=64 Then SS$=SS$+"Left Meta|"  
			If (SS & 128)=128 Then SS$=SS$+"Right Meta|"  
			If (SS & 256)=256 Then SS$=SS$+"Caps Lock|" ' Only for AOZ  
			If (SS & $8000)=$8000 Then SS$=SS$+"Left Ctrl|" ' Only for Amiga  
		End If  
	SS$=SS$+Space$(160) ' more than enough spaces to erase previous states from display.  
	Locate 0,3 : Print SS$  
	SS$=""  
	End If
	
Refresh 
Loop
```
The example above will display the _last key_ pressed along with the modifier keys which were pressed at the same time.

---
<p align="center"><img valign="middle" width="76px" src="https://doc.aoz.studio/assets/images/en/image001.png" />
</p>
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE4OTQxMTI4MjYsMTIzMTE4NjA5NiwtOT
U2NzIwMzg0LC0yMDc4MDA5ODk0LC0xNzQ4NjQzMzg4LC04NDcx
OTQwMzMsLTE2MDI1OTg4MzQsMTA5MjM0MjM5MSwtMTE3ODkxNz
g2OSwxNTI4MjQyOTc1LC04NzYyNzU2MTYsLTEzMDQwNTQ5MjUs
LTU5ODMxOTExLDE1MjE3MDc3OTMsODcwMjMyMDI2LDczMDk5OD
ExNl19
-->